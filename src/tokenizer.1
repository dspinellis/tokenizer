.TH TOKENIZER 1 2023-05-21
.SH NAME
\fBtokenizer\fR \(en convert source code into integer vectors
.SH SYNOPSIS
\fBtokenizer\fR [\fB\-l \fIlang\fR] [\fB\-o \fIopt\fR] [\fB\-t \fItype\fR] [\fIfile ...\fR]
.SH DESCRIPTION
The \fBtokenizer\fR utility converts source code specified as files in
its command line or provided through its standard input into one of several
supported output formats.

.SH OPTIONS
The behavior of the \fBtokenizer\fR utility can be controlled
through the following command-line options.
.RS 3

.TP
.BI "-l " lang
Specify the input language.
Currently the following languages are supported:
\fIJava\fP, \fIC\fP, \fICSharp\fP (or \fIC#\fP), \fIC++\fP, \fIPHP\fP,
\fIPython\fP.

.TP
.BI "-o " opt
Specify a language-specific processing option.
Multiple \fB-o\fP arguments may be provided.
The following processing options are supported.

.RS 3

.TP
.B file
Output a single vector for the whole file.

.TP
.B line
Output one vector per input line.
Input and output lines are synchronized, allowing the tracking
of tokens to their original line position.

.TP
.B method
Output a vector for the contents of each method.

.TP
.B statement
Output a vector for each statement.
.LP
.RE

.TP
.BI "-t " type
Specify the output type.
The following output types are supported.

.RS 1

.TP
.B n
Output numeric token values.
This is the default.
.RS 3
.IP \(bu
Characters are output as values in the range 0\(en255.
.IP \(bu
The language's keywords are output as values in the range 300\(en599.
Other multi-character tokens (e.g. \fC+=\fP) are output as values
in the range 600\(en1099.
The numbers for the same keywords are the same between different languages,
allowing the tokenizer to be used to train models through transfer learning.
.IP \(bu
Numbers are output on a base-ten logarithmic scale centered around 1100
and extending 400 values around it;
in addition zero is represented as 1500.
.IP \(bu
Other constants (e.g. characters and strings) are represented as an integer
representing the corresponding type.
.IP \(bu
Comments are mapped into a single integer.
.IP \(bu
White space is not included in the output.
.IP \(bu
Identifiers are output as a value starting at 2000.
Identifiers with the same name within a scope get the same value.
Identifiers that have not appeared in any enclosed scope get a new value.
.RE

.TP
.B c
Output the original code tokens, one per line.
Comments and strings are output with their content replaced by an
ellipsis (...).
All other tokens are output in their original form.
This output format can be passed to line-difference programs
in order to process the code at the level of individual tokens.

.TP
.B s
Output symbolic token values.
.RS 3
.IP \(bu
Single character tokens and reserved words are output in their original form.
.IP \(bu
Other language tokens are output as a symbol representing them.
.IP \(bu
Numbers are output in scientific notation as 1, prefixed by "~",
and followed by a varying exponent according to the number's base-ten logarithm.
.IP \(bu
Identifiers are prefixed by "ID:" and followed by an integer corresponding to
the identifier number defined for numeric token values.
.RE

.TP
.B t
Output the type of each token.
This output is similar to the of symbolic token values,
with the exception that all identifiers and numbers are treated as the same.

.TP
.B T
Output the type of each token (ID, KW, NUM, or TOK) and the actual token,
one entry per line.

.LP
.RE

.RE

.SH EXAMPLES
.PP
Process a file with default options.
.ft C
.nf
tokenizer file.c
.ft P
.fi

.PP
Process a file specifying a vector per method.
.ft C
.nf
tokenizer -l Java -o method File.java
.ft P
.fi

.SH DIAGNOSTICS
An error is displayed when an end of file is encountered while processing
a block comment or a character or string literal.

.SH AUTHORS
Written by Diomidis Spinellis.

.SH BUGS
The tokenizer is more permissive than the corresponding language specifications.
For example, number literals can contain arbitrary letters in them,
in addition to the recognized \fC0x\fP and \fC0b\fP prefixes.
Also string and character literals can contain arbitrary backslash-escape
sequences, in addition the defined ones.
.PP
Continuation lines are not supported.
.PP
The processing context may get confused by unbalanced braces occurring in
C preprocessor macro definitions.
.PP
The Python tokenizer does not support processing options and identifier
scoping.
